---
title: About Reanimated
---

# Motivation

---

`Reanimated` was written to get rid of several limitations present in `Animated` library, such as excessive communication between native and JS when running complex animations (e.g. composing animations and starting some by `.start()` from JS side), API implemented in native and JS side (updating node behavior requires changing code in 3 places, which is more error-prone than changing only JS code), and too high abstraction over animations (which prevents implementing some animations without changing library code).

Watch [Krzysztof Magiera's talk](https://www.youtube.com/watch?v=kdq4z2708VM) at React Europe 2018 for more insight about motivation to create `Reanimated`

`Reanimated` aims to:

- Provide more generic and low-level primitive node types which allow creating more complex nodes from them
- Remove “useNativeDriver” – all animations run on the UI thread by default
- Allow conditional evaluation & nodes with side effects (`set`, `startClock`, `stopClock`)
- Keep native modules as minimal as possible

## Reanimated compatibility

`Reanimated` tries to be fully compatible with the `Animated` API. We believe that the set of base nodes we have selected should make this possible to be done only by writing JS code and does not require significant changes in the native codebases. Here is a list of things that haven't been ported from the original version of the `Animated` library yet.

All the functionality from `Animated` can be achieved with `Reanimated`, although a different methodology for implementing those may be required (e.g. check ["Declarative Animation API" section](declarative-animation-api.html) to see how the implementation may differ)

- [ ] using value offsets
- [ ] value tracking (can be achieved in different way, `react-native-reanimated` also allows for tracking all the animation parameters not only destination params)
- [ ] animation staggering
- [ ] animation delays

## At most once evaluation algorithm

Unlike the original `Animated` library where each node could have been evaluated many times within a single frame, `Reanimated` restricts each node to be evaluated at most once in a frame.
This restriction is required for nodes that have side-effects (e.g. [`set`](set.html) or [`startClock`](start-clock.html)).
After a node is evaluated (e.g.in case of an [`add`](add.html) node we want to get a sum of the input nodes) it's value is cached. If in the next frame other nodes uses that node value, cached node's value is returned instead of evaluating it more than once - resulting in better performance as nodes evaluate only when needed.

The current behavior of selecting nodes for evaluation works as follows:

1.  We analyze the generated events in the native side from the previous frame (e.g. touch stream) which can lead to updating some nodes
2.  Then we update values that correspond to "running" [clock](clock-and-the-algorithm.html) nodes
3.  We traverse the node's tree starting from the nodes updated in the current frame and we look for final nodes connected to views
4.  If we found nodes connected to view properties we evaluate them. This can recursively trigger an evaluation for their input nodes etc.
5.  After everything is done we check if some "running" clocks exists. If so we enqueue a callback to be evaluated with the next frame and start over from pt 1. Otherwise we do nothing

## 100% declarative gesture interactions

`react-native-reanimated` works best with the [Gesture Handler](https://kmagiera.github.io/react-native-gesture-handler) library. Currently all the examples are made using that library, including the ultimate
[ImagePreview app](https://github.com/software-mansion/react-native-reanimated/blob/master/Example/imageViewer).
